# Gin源码分析

## 琐碎信息

gin底层使用的还是http.ListenAndServe

gin的engine中使用了pool对象池，申请某些对象时，每次都从该pool中取出后再对对象初始化。池化的思想！！[有待扩展]

在全局中声明`var _ IRouter = &Engine{}`  是为了保证Engine这个结构体实现了IRouter接口

label 的使用在for循环前使用个label来记录for循环的名称，后续方便使用continue、goto、break语句

注意，一个企业级的代码要将鲁棒性给写的很完善，比如从Context中获取userID，我们可以直接利用gin中Context的get函数来获取。但是我们会将这个过程封装成一个方法放在request.go中，其实该方法主要处理各种err，用于安全性，主体就是两条语句：调用get，并类型转化成int64

划分模块时注意模块间的关系，防止出现循环引用的问题！

## 路由Radix树

###### 为什么路由不使用哈希？

答：当路由中使用通配符时，使用哈希就不方便处理其中的通配符。使用前缀树方便匹配路由中的参数信息。

基数树（Radix树），又称为PAT位树，是一种压缩空间的**前缀树**。应用在linux内核中。

特点：

1. 对只有一条子路径的节点进行压缩，压缩成一个节点

2. 在进行单词比较时，不是逐字符比较，而是逐比特位，每次比较r个比特位，也就说2的r次方是树的基数。

在gin的路由基数树中的特点：

1. 为每个请求方法管理同一棵树。比如GET一棵树，POST一棵树。这样比为每个路由节点设置method请求方法来更能节省空间

2. 为每个节点设置优先级，在同一级的子节点中，优先匹配优先级高的子节点。其中优先级为`该节点的子树中句柄handle的数量`。
   
   **原因1**：某节点能匹配的路由越多，就越应该优先找该节点，这样匹配成功的概率越大。**原因2**：某种程度的**成本补偿**。长路径往往需要更长时间来定位，所以优先选择匹配长路径。本来单个长路径匹配时间就长，如果等优先匹配短路径失败了再来匹配长路径的话，那不得慢死。。。

# Go连接Mysql

## database/sql包

该包只提供接口，不提供sql的驱动，使用前一定要注意导入驱动

该包是典型的面向接口编程，包中全是接口，这样就保证即使使用不同的驱动，只要保证实现这些接口，代码就可以原封不动地运行

原生的sql不支持绑定结构体，因此比较啰嗦

增删改查注意事项：

1. 注意连接池的大小，如果在查询后不scan，连接就会不释放，就会一直占用连接池中的该连接资源。或者使用Close释放

2. 使用原生的事务比较麻烦，因为每一次执行语句以后，如果失败，都要回滚，这就造成了重复代码比较多

## _sqlx包

可以直接将结果与结构体绑定

## Mysql预处理

###### 什么是预处理？

将mysql分为两部分：命令部分和数据部分

先将命令部分发送给服务器，服务器进行sql预处理

然后把数据部分发送给服务器，对sql占位符进行替换

###### 为什么要预处理？

1. 优化大量命令重复的仅仅是数据部分不同的sql语句

2. 避免sql注入

###### 什么是sql注入

使用用户输入的内容拼接sql语句时，用户内容违法就会改变sql语句的含义

**任何时候都不能信任用户输入的数据！！**

# Go-redis

go-redis自带连接池

###### pipeline

在网络中，客户端通常会缓冲一堆命令并一次性将它们发送到服务器，这样节省了网络来回的RTT时间。

在某些场景下，如果有多条命令要执行，且这些命令前后没有依赖，那么就可以用pipeline优化for循环

###### redis中的事务

redis是单线程的，能保证单条命令是原子的，但是无法保证事务。因此需要调用包中的函数来实现事务。

###### watch

在执行事务时要判断watch某些状态或变量，如果事务执行过程中该状态量发生变化，则事务执行失败。于是就使用watch来监控业务函数中该状态量是否发生变化。

比如交易过程中，如果商品剩余量或者商品价格被另一个客户端修改，那么就交易失败。

# 配置库

## zap日志库

对性能要求高，就使用Logger

如果对性能要求不是特别高，就使用SugaredLogger

使用zapcore.NewCore创建一个日志的配置，并可以根据该配置生成一个日志

配置以下信息：日志编码器、日志目录、哪种级别的日志可以被写入

###### 如何将zap日志融入gin框架中

模仿gin框架的Logger和Recovery中间件，将其中的日志打印改成zap日志打印。

新建一个gin框架的空引擎，加入新写的两个中间件即可

## viper配置库

viper配置有优先级，会优先使用优先级高的配置中的值

使用watchConfig动态监控配置

注意viper加载配置时使用的是相对路径，是调用程序目录的相对路径。在哪里输命令行运行程序，相对路径就从哪里开始

# 如何优雅关机或重启

###### 如何关机

如何实现关机时并不是强制关机，而是等待当前还在处理的请求全部处理完毕后再退出程序？

使用http.Shutdown() 支持优雅关机

用goroutine启动业务线程，然后在主线程中使用channel来接收中断信号，阻塞在channel处。当channel收到操作系统发来的kill的信号时，就会向下执行Shutdown来优雅关机

###### 如何平滑重启

使用endless库，该库不适用于supervisor

基本思路：

endless库实现思路：当程序收到重启信号时，开启一个子进程，由父进程处理重启前未收到的请求，子进程处理新的请求。父进程处理完成后，父进程关闭，由子进程来接管业务。

## Goweb分层理念

## MVC模式

Model：存放数据对象

View：数据可视化

Controller：控制数据流向model，并在数据变化时更新view

这种模式已经被淘汰了，取而代之的前后端分离

### CLD模式

Controller：服务的入口，负责处理路由、参数校验等。即GET路由后面跟着的就是这一层对应的处理函数，在该函数中逐级向下渗透

Logic/Service：逻辑层，负责处理业务逻辑

DAO：负责数据与存储功能

## go web脚手架模版

总共分为以下几步：

1. 加载配置文件

2. 初始化日志

3. 初始化mysql连接

4. 注册路由

5. 启动服务(优雅关机)

目录设置：

1. mysql和redis相关文件放在dao目录下

2. 日志放在logger目录下

3. 配置文件放在setting下

4. 注册路由放在routes目录下

# 项目实战

## 编程小细节

1.在函数返回时，一般不返回bool，而是返回一个error，根据err是否为nil来判断是否成功

2.在给redis的字符串常量命名时，尽量使用类似于命名空间的方式进行命名，比如”project:user:time“，这样方便查询和拆分。方便集群运行多个项目时对redis的区分。

3.在tag中json字段后面添加`omitempty`，表示当该字段不为空时才将该字段序列化

4.想要从url中获取参数，可以将要获取的参数封装成结构体，使用gin的shouldBind绑定到结构体中即可。

## 数据库设计

###### 为什么不用数据库的自增id作为user_id

1. 用户注册id就能知道数据库中一共多少个用户，造成数据泄露

2. 分表时，会造成重复id

###### 为什么不使用uuid

UUID是无规律的，排序时不方便

###### 分布式id生成器

分布式id特点：

1. 全局唯一：没有重复的ID标识

2. 确保生成ID对于用户或业务是递增的

3. 高并发下表现良好

在短时间内有大量消息，比如短时间内大量订单或大量微博转发评论，就可以用分布式id

**使用雪花算法生成分布式ID**：

使用snowflake库

<img src="file:///C:/Users/24298/AppData/Roaming/marktext/images/2024-12-17-21-47-15-image.png" title="" alt="" width="383">

bit位分为时间戳、序列号、工作机器id

时间戳以毫秒为单位，每毫秒开始，后面的序列号归零重新计算。这么多bit位能记录69年的时间长度。使用时传入startTime，获取id是时间戳记录的是当前时间与startTime时间相比较的增量值。

工作机器就是分布式机器id，其每毫秒产生序列号从0开始不断累加

由于时间戳在最前面，可以保证生成的id在**单机上**递增

ps：另外索尼公司也使用了类似于雪花算法的id生成器，只不过位数略有不同，且时间戳间隔为10ms

我们将startTime和machineId记录到配置文件中，每次开启时先加载配置文件，将startTime传入到snowFlake中，后续再正常生成节点

## 注册流程

route.go注册路由------>注册请求处理函数由controller/user.go来控制，负责参数校验，校验成功后进行业务处理------>logic/user.go来进行注册时的业务处理，比如注册ID等------>dao层负责业务处理过程中需要的数据存储，比如mysql或redis等操作

### 参数校验

**与数据库相关的数据，打包成结构体，放到models的目录下**

在获取参数时让context绑定即可

当然，可以直接使用Validator第三方库来进行参数校验，支持翻译成中文等功能，可以通过对字段打tag来验证该字段是否满足参数

检查密码是否填完等操作在参数校验这一步

### 创建用户流程

参数校验成功后的业务处理

1. 判断用户名存不存在

2. 生成UID

3. 构造一个User实例

4. 插入到数据库中(插入时记得对密码加密)

### 登录用户流程

参数校验成功后的业务处理

1. 检查用户名存在不存在

2. 从数据库中拿出密码字段，将用户输入密码加密后看是否与该密码相同

### 封装错误码和响应方法

在control这一层中，code.go中定义各种状态码的常量以及其对应的msg信息

同样是control这一层，定义一个response.go，传入gin上下文c与状态码，自动向c中返回对应的信息

在Dao的mysql中的错误，直接使用常量定义error类型，在control/user.go这一层，根据判断是哪种错误类型从而使用response中的哪种返回函数

### 用户认证

由于Http协议是无状态的协议，因此在一次请求后，下次在发送服务器时不知道这次请求是谁发送的（同一个IP不代表同一个用户）。

#### cookie-session认证模式

客户端发送数据时，服务器生成并存储sessionID，并返回客户端

客户端浏览器的cookie中会存储该sessionID

下次再访问该服务器时，会携带该sessionID，服务器会对sessionID进行验证，从而认证用户

这种模式存在的问题：

1. 存放sessionID需要大量资源，用户较多时占用资源多

2. 创建Session的服务器不一定是验证Session的服务器，因此需要将所有Session共享

3. 客户端使用Cookie存储SessionID，钓鱼网站有可能利用cookie而进行攻击

#### Token认证模式

服务器端根据客户端的信息生成token并发送给客户端，客户端将token存储在存储系统中

而服务器端不再花费资源存储有效的token

下一次客户端请求时，会携带token，服务器收到token后通过固定的编码解密流程和服务器专属的密钥对token进行解密，从而鉴权

优点：

1. 服务器不用花资源存储session

2. 不依赖Cookie

缺点：

1. Token在其有效期内一直可用。session方式还可以通过销毁sessionID来让某用户不可用，但是Token很难实现。因此只能将Token的有效期设置的很短。

#### 常用的Token认证模式：JWT  Json Web Token

JWT Token编码分为三部分：

1. 头部：存放加密算法和token类型

2. 负载：以json的形式存放各种信息对象（因为JWT默认不加密，因此这部分可以解密，不能把秘密信息放到这一部分）

3. 签名：对前两部分的加密，防止被数据篡改，通过签名保证安全性

当服务器收到token后，会根据服务器保存的密钥以及头部保存的加密算法对前两部分进行加密，如果得到的结果和签名不同，证明已经数据已经被篡改

一般会Token会放在客户端的“Authorization”字段。

Token可以放在请求头，也可以放在请求体，也可以放在URI

#### 如何在项目中使用jwt

使用jwt-go这个库

使用jwt-go可以写生成Token和解析Token函数

将使用jwt验证Token写成中间件，在需要登录后才可以访问的路由中，添加该中间件进行验证即可。

在该中间件中，如果验证了Token通过的话，就将信息存放到context中，这样之后需要获得userID时就从context中获取

#### 刷新Token   Refresh Token

这个项目中没用到，但是要了解

之前记录信息的token是access token，前文说过，一般token的有效期很短，而如果我们想实现一直登录会怎么办呢？

就设置一个Refresh Token，该Token的负载中只记录是否过期，而不记录其他信息。一般Refresh Token的有效时间很长

发送过程：access Token正常发送，直到某次access token过期时，服务器收到过期信息会返回一个状态码表示token过期，此时客户端会发送refresh token。如果refresh Token未过期，则服务器会重新发送一个access Token。如果refresh过期了，根据具体业务判断是要拒接连接还是说也重新发送一个新的refresh Token

#### 如何实现限制同一个账号同一时间只能登录同一个设备

比如防止两个设备用同一个账号可以看同一个付费视频

首先两个人在不同设备上如果登录同一个账号，首先登录时间肯定是不一样的，这样我们在服务器中保存该账号对应的最新的token。

这样后续客户端发送观看视频请求时，检验token与服务器中存储的token是否相同，不同的话则需要重新登录。

虽然Token是为了节省资源存储，但是有时候不得不使用额外资源记录

## 为go编写makefile

用于方便编译过程

使用`make xx`  会运行makefile中的对应命令

如果只使用`make` 默认执行makefile中的all

## 使用air第三方库实现文件热加载

文件热加载，即当修改代码并保存之后，会自动重新编译并运行一遍代码

## 帖子模块设计

帖子的数据库表结构主要由以下几个部分：帖子id、标题、内容、所属社区、作者的用户id、帖子状态、创建时间、更新时间

创建三个索引：帖子id、作者id、所属社区id

###### 优化

当我们从数据库中查询到帖子信息时，还要根据作者id来搜索作者的相关信息并显示

在这种情况下，可以将需要的信息封装成一个结构体中，方便api查询。而且该结构体可以通过内嵌指针实现

## 前后端json序列化与反序列化时失真问题

在后端json序列化与反序列化本身没有问题

问题是在前端JS的格式的数据范围为1<<53-1，要小于后端能表示的数据范围，如果将id传给前端的话，有可能导致前端的id值失真。因此需要将id值转化成string类型返回前端

在对应字段的tag中，在json后面加上`string`即可，比如`json:"id,string"` ，这样在序列化时会转化成string类型，反序列化时也接受一个string类型

## 投票(点赞 或 点踩)功能

为帖子post投票功能通过redis实现，而不需要放到mysql中

redis建立以下几张表Zset：

1. 建立post_time表，保存每个post和对应的建立时间，为后续判断时做准备

2. 建立post_score表，保存每个post和对应的得分

3. 为每个post_id都建立一个表，表中的键值对为{user_id,score} 表示该用户为该帖子点赞\点踩\无操作行为

注意：

1. redis中ZAdd、ZIncrBy等操作是原子的，但是有些地方需要实现事务操作。比如向帖子相关的redis表添加键值对时，用事务将创建过程包裹起来。在修改用户给帖子的得分时也一样。

2. 帖子得分如何计算？创建帖子时的初始得分为时间戳，这样，越是新帖子，初始得分就越高，排名就越高。此后每次投票时，会让这个得分加某个权值。这个权值由时间综合计算得出，比如想要200个点赞就会让优先级提高一天，就将1天的时间间隔/200即可得到一票的权值。

## 按照帖子score得分显示帖子列表

如果按照创建时间对帖子排名，可以使用mysql中的语句，因为mysql中存储了帖子的创建时间

但是在该项目中，score仅存放在redis中，那如何实现呢？

1. 从redis的zset列表中使用ZRevRange用降序查询指定范围内的id列表

2. 从数据库中使用in查询，同时使用FIND_IN_SET函数维护给定id集合的顺序

## 获得每个帖子的点赞数

在获得该页帖子的id列表的情况下，在redis中使用pipeline在每个post-id对应的redis表中点赞数量

## 按照得分排序来查看某个社区中的帖子

为每个社区id创建一个set，将社区的set与得分排序的zset联合起来，使用ZInterStore(相当于取交集)联合成一张新的redis表，在该表中查询。

## 编写gin的测试样例

写网络类的测试，使用httptest

1. 将gin设置为testmode

2. 设置一个路由，一个http.NewRequest,一个w=httptest.NewRecorder，用来发送请求并记录响应

3. 判断w中的字段是否与预期相同(assert.Equal)

## 使用swagger生成接口文档

1. 专门在c层建立一个go文件用来存接口的结构体

2. 写注释

3. 执行命令swag init。如果生成成功，会有一个docs文件夹，将该目录引入

4. 注册swagger的路由

## http服务压力测试

在windows下使用go-wrk，是go版本的wrk

## 限流策略

### 漏桶策略

类似于一个桶下面有一个洞，水滴流下的速率是一样的，每隔相同的时间流下一滴水滴(一个请求)

这种策略的核心就是**按照固定速率处理客户端**的请求。无论请求有多么多，都按固定速率进行处理。

缺点：不适合有大量突发请求的场景，比如整点秒杀

### 令牌桶

<img src="https://www.liwenzhou.com/images/Go/ratelimit/lingpaitong.jpg" title="" alt="令牌桶原理" width="347">

按固定速率将令牌放入令牌桶中，当客户端请求时，如果桶中有令牌，就取令牌并处理请求；如果没有就等待或拒绝返回。

令牌桶**支持大量突发请求**，原因：令牌桶中可以积攒令牌，因此某一时刻如果有大量请求，可以将积攒的令牌给消耗掉。

###### 如何应用？

如何在gin框架中限流？将令牌桶封装成中间件，在gin框架中添加中间件。

### 漏桶令牌桶源码

漏桶使用的是uber团队的第三方库

go中的令牌桶可以使用juju/ratelimt的实现

###### 漏桶

实现比较简单，每次Take()取水滴函数都lock操作，执行完函数中所有语句以后再unlock

记录上次水滴流下的时间，如果需要等待，就sleep等到下一次水滴流下

uber在构造时中使用了option选项模式

###### 令牌桶源码

令牌桶实现时，没必要每次都模拟放入令牌。直接记录上一次取令牌的时间，在下一次要取令牌的时候算出这段时间应该有多少个令牌放入桶中即可。

### pprof进行性能优化

使用pprof进行性能测试分析

### 使用docker部署项目

由于go最后生成一个二进制的可执行文件，因此在docker中其实不需要一直保留go环境也可以执行

实现：在镜像中编译，编译后创建一个小镜像，将可执行文件拷贝到小镜像中运行

在使用多个容器时，使用docker-compose进行部署

本项目中只对redis和mysql起docker，然后设置yaml文件本题跑

## 部署情况（遇到的问题）

###### 部署nodeJS前端

部署时，使用npm install下载对应的依赖一直失败，换源换成腾讯云、阿里云都没用

解决方法：换成华为云就好了！

###### 字段不对应

注册时一直失败

注册时前端出来的验证密码的字段的json与结构体的字段json名称不一样

###### 前端验证Token一直失败

用postman验证了一下浏览器中的token是没问题的，但是浏览器发请求时一直是Bearer undefined。

解决方法：前端请求的字段是token，而后端的键值是accessToken，将后端的键改为token后成功

###### 一直无法显示社区列表

通过F12看浏览器网络及响应情况，发现前端发送社区请求后，后端正常返回社区列表，说明没问题。

于是使用postman创建帖子。创建后，回到前端页面，发现投票、按时间排序等功能可以正常运行。
